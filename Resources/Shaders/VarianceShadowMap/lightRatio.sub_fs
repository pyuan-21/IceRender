/*light info*/
struct LightCamInfo
{
	mat4 lightMat;
	float near;
	float far;
	vec3 lightCamPos;
	vec3 lightViewDir;
};
uniform LightCamInfo lightCamInfos[maxLightNum]; // "maxLightNum" is defined in "phong_vsm.main_fs"

/*shadow map*/
uniform sampler2D shadowMaps[maxLightNum]; // "maxLightNum" is defined in "phong_vsm.main_fs"

/*SAT-VSM related, refer GPUGems3: SummedArea Variance ShadowMaps*/
uniform int halfKernelSize; /*half kernel size: e.g. 2 is 5X5 kernel*/
uniform float varMin; /*minimum variance to reduce numeric inaccuracy(also biasing)*/
uniform float pMin; /*remove range[0, pMin], then rescale pMax from range[pMin, 1] to [0,1]*/
uniform int useSAT; /*indicate whether use SAT to do filtering*/
uniform sampler2D SATMaps[maxLightNum]; // "maxLightNum" is defined in "phong_vsm.main_fs"


/*Given a center, half kernel size and its SAT map, return the mean of this kernel area*/
vec2 GetMean(ivec2 texSize, ivec2 center, sampler2D SATMap)
{
	// [Note] texel space coordinate is inside [0, resolution-1]. 
	ivec2 minCorner = center - ivec2(halfKernelSize+1);
	ivec2 maxCorner = center + ivec2(halfKernelSize);
	// don't clamp corner first, because we do need some values which are out of range to compute true sum.
	// those elements out of range will return border value, here it is zero.
	vec4 result4 = texelFetch(SATMap, maxCorner, 0) - texelFetch(SATMap, ivec2(minCorner.x, maxCorner.y), 0) - texelFetch(SATMap, ivec2(maxCorner.x, minCorner.y), 0) + texelFetch(SATMap, minCorner, 0);

	// compute the real number over kernel area, must clamp corner.
	minCorner = clamp(minCorner, ivec2(0), texSize-ivec2(1));
	maxCorner = clamp(maxCorner, ivec2(0), texSize-ivec2(1));
	int totalNum = max(maxCorner.x-minCorner.x, 1) * max(maxCorner.y-minCorner.y, 1);
	vec2 loss = vec2(0.5); // don't forget compensate this loss
	vec2 menOutput = result4.xy/totalNum + loss; //totalLoss = loss * totalNum-> its mean loss is loss
	return menOutput;
}

struct TexelInfo
{
	ivec2 lb, lt, rb, rt; /*four texel coordinates at four corners over a rectangle area*/
	vec2 weight;
};

/*return four texels which are surrounding the uvCoord. We can use these four texels to do bilinear interpolation*/
TexelInfo GetFourTexels(ivec2 texSize, vec2 texelSize, vec2 uvCoord)
{
	float weightX, weightY;
	int minX, maxX, minY, maxY; // in texel space [0, resolution-1]
	ivec2 texelNum = ivec2(uvCoord/texelSize); // check how many completed texels it has already contained.
	vec2 offset = uvCoord - texelNum*texelSize;
	vec2 halfTexelSize = 0.5 * texelSize;
	
	// X direction
	if(offset.x < halfTexelSize.x)
	{
		minX = texelNum.x - 1;
		weightX = (halfTexelSize.x+offset.x)/(texelSize.x);
	}
	else
	{
		minX = texelNum.x;
		weightX = (offset.x-halfTexelSize.x)/(texelSize.x);
	}
	maxX = minX + 1;

	// clamp the range, must execute after computation. Don't do it above
	minX = clamp(minX, 0, texSize.x-1);
	maxX = clamp(maxX, 0, texSize.x-1);

	// Y direction
	if(offset.y < halfTexelSize.y)
	{
		minY = texelNum.y - 1;
		weightY = (halfTexelSize.y+offset.y)/(texelSize.y);
	}
	else
	{
		minY = texelNum.y;
		weightY = (offset.y-halfTexelSize.y)/(texelSize.y);
	}
	maxY = minY + 1;

	minY = clamp(minY, 0, texSize.y-1);
	maxY = clamp(maxY, 0, texSize.y-1);

	TexelInfo texelInfo;
	texelInfo.lb = ivec2(minX, minY);
	texelInfo.lt = ivec2(minX, maxY);
	texelInfo.rb = ivec2(maxX, minY);
	texelInfo.rt = ivec2(maxX, maxY);
	texelInfo.weight = vec2(weightX, weightY);

	return texelInfo;
}

/*return bilinear interpolation*/
vec2 GetBilinearValue(vec2 lb, vec2 lt, vec2 rb, vec2 rt, vec2 weight)
{
	vec2 res1 = mix(lb, rb, weight[0]); // bottom horizontal interpolation
	vec2 res2 = mix(lt, rt, weight[0]); // top horizontal interpolation
	return mix(res1, res2, weight[1]); // from bottom to top, vertical interpolation
}

/*average the depth/depth_square over kernel*/
vec2 GetMoment(vec2 uvCoord, sampler2D shadowMap, sampler2D SATMap)
{
	float M1 = 0.0, M2 = 0.0;
	
	/*moment is vec2(E(x), E(x^2)), that's why we need a kernel to filter an area to get mean*/
	/*filtering*/
	if(useSAT == 1)
	{
		// [Note] texel space coordinate is inside [0, resolution-1]. 
		ivec2 texSize = textureSize(SATMap, 0);
		vec2 texelSize = 1.0/texSize;

		/*nearest mean*/ 
		{
			//ivec2 center = ivec2(uvCoord/texelSize);
			//center = clamp(center, ivec2(0), texSize-ivec2(1));
			//vec2 nearestMean = GetMean(texSize, center, SATMap);
			//M1 = nearestMean.x;
			//M2 = nearestMean.y;
		}

		/*Bilinear interpolation is better*/
		TexelInfo texelInfo = GetFourTexels(texSize, texelSize, uvCoord);
		vec2 lbMean = GetMean(texSize, texelInfo.lb, SATMap);
		vec2 ltMean = GetMean(texSize, texelInfo.lt, SATMap);
		vec2 rbMean = GetMean(texSize, texelInfo.rb, SATMap);
		vec2 rtMean = GetMean(texSize, texelInfo.rt, SATMap);

		/*We need to do linear interpolation by ourselves. SAT can not use texture() to get value.*/
		/*SAT is texel based, can not be used to interpolation.*/
		vec2 biliRes = GetBilinearValue(lbMean, ltMean, rbMean, rtMean, texelInfo.weight);
		M1 = biliRes.x;
		M2 = biliRes.y;
	}
	else
	{
		vec2 texelSize = 1.0/textureSize(shadowMap, 0);
		int totalNum = 0;
		for(int i = -halfKernelSize; i <= halfKernelSize; i++)
		{
			for(int j = -halfKernelSize; j <= halfKernelSize; j++)
			{
				vec2 value = texture(shadowMap, uvCoord+vec2(i,j)*texelSize).rg;
				M1 += value.r;
				M2 += value.g;
				totalNum += 1;
			}
		}
		float invSize = 1.0 / totalNum;
		M1 *= invSize;
		M2 *= invSize;
	}

	return vec2(M1, M2);
}

float ComputeChebychevUpperBound(float t, vec2 moment)
{
	if(t<=moment.x)
		return 1.0;

	/*moment is vec2(E(x), E(x^2))*/
	float differ = t - moment.x; /*depth minus mean*/
	/*using this math formula will get some variance less than zero because of float-precision or other reason*/
	float variance = max(moment.y - moment.x*moment.x, 0); /*variance square*/
	variance = max(variance, varMin);
	return variance / (variance + differ*differ);
}

float ComputeLightRatio(LightCamInfo lightCamInfo, sampler2D shadowMap, sampler2D SATMap)
{
	/*ComputeLightRatio: lightRatio is inside [0, 1]*/
	vec4 clipCoord = lightCamInfo.lightMat*modelMat*vec4(fPos,1.0); /*clip space*/
	vec3 ndcCoord = clipCoord.xyz / clipCoord.w; /*ndc space: [-1,1]^3*/ 
	vec3 shadowCoord = (ndcCoord+1)/2.0; /*map [-1,1]^3 to [0,1]^3*/
	/*note this frageDepth is not clipped. We need to check it by ourselves if neccessary.*/  
	/*we can just set no-shadow for those vertices which are outside of the light view frustum*/
	//float fragDepth = shadowCoord.z; // this is projected depth, don't use it

	/*[Important] for avoid projected z-depth precision issue, using linear depth not projected depth*/
	/*we know z values near to far plane will be hard to compare*/
	vec3 worldPos = (modelMat*vec4(fPos,1.0)).xyz;
	vec3 v = worldPos - lightCamInfo.lightCamPos;
	vec3 proAxis = normalize(lightCamInfo.lightViewDir);
	float linearDepth = dot(v, proAxis);
	linearDepth = (linearDepth - lightCamInfo.near) / (lightCamInfo.far - lightCamInfo.near);
	float fragDepth = linearDepth;

	vec2 moment = GetMoment(shadowCoord.xy, shadowMap, SATMap);
	float pMax = ComputeChebychevUpperBound(fragDepth, moment);
	pMax = (pMax-pMin)/(1.0-pMin); /*linear interpolation-map the [pMin, 1] to [0, 1]*/
	pMax = clamp(pMax, 0, 1);

	return pMax;
}