/* This file is automatically generated by "Resources/Shaders/ScreenSpaceAmbientOcclusion/ssdo.iter_fs". */
/*SSDO only works for deferred shading*/
/*refer: "Approximating dynamic global illumination in image space"(SSDO) [T. Ritschel, T. Grosch, and H.-P. Seidel. 2009]*/
#version 450 core

#pragma optionNV (unroll all)
#pragma optionNV(fastmath on)
#pragma optionNV(fastprecision on)

#ifndef PI
#define PI 3.1415926538
#endif

uniform mat4 viewMat;
uniform mat4 projectMat;
uniform float ssdoSampleRadius; /*sample raidus over hemisphere*/

/*neccessary input from deferred shading fragment shader: */
in vec2 fUV; /*- fUV (uv coordinate from screen quad)*/
uniform sampler2D posTex; /*- posTex (position texture in world space)*/
uniform sampler2D normalTex; /*- normalTex (normal texture in world space)*/

/* output */
layout (location = 0) out float aoTex;

/* global variables */
vec3 fPos, fNormal;

/* for DO wi(direction) sampling */
float deltaTheta, deltaPhi;

/* for rotate samplie direction */
mat4 rotateMat;
vec3 ePos;


vec3 PosToTexCoord(vec3 samplePos)
{   
    /* samplePos should be in view space */
	vec4 projectedPos = projectMat * vec4(samplePos, 1);
	vec3 ndcPos = (projectedPos / projectedPos.w).xyz; // map to [-1, 1] -> NDC pos
	vec3 sampleTexCoord = (ndcPos + vec3(1)) / 2.0; // map to [0, 1] -> texCoord
	return sampleTexCoord;
}

bool CheckOutside(vec3 texCoord)
{
	// whether texCoord is outside
	if(texCoord.x < 0 || texCoord.x > 1 || 
        texCoord.y < 0 || texCoord.y > 1 || 
	   	texCoord.z <= 0 || texCoord.z >= 1)
    {
	   	return true;
	}
	return false;
}

int CheckVisibleByDepth(vec3 sampleTexCoord)
{
	if(CheckOutside(sampleTexCoord))
    {
		// note: for each sample point outside view frustum (not seen in view space), treate it as visible.
		return 1;
	}

	// get sampleDepth. This depth is the projected depth of sample point.
	float sampleDepth = sampleTexCoord.z;

    // get frontDepth. This depth is using the projected uv from sample point 
    // to get the depth information from texture (not gonna use current fragment's depth)
	vec3 frontPos = texture(posTex, sampleTexCoord.xy).rgb; // in world space
	frontPos = (viewMat*vec4(frontPos, 1)).xyz; // converted to view space
	vec3 frontTexCoord = PosToTexCoord(frontPos);
	float frontDepth = frontTexCoord.z;

    /* TODO: for solving depth peeling, we need a backface depth texture
	// get backDepth
	// float backDepth = texture(dpTexture, sampleTexCoord.xy).r; // back-face depth for depth peeling
	// using depth peeling method, sample point inside is not visible.
	// if(sampleDepth >= frontDepth && sampleDepth <= backDepth)
    */

	if(sampleDepth >= frontDepth)
		return 0;
	else
		return 1;
}

int ComputeVisibility(int i, int j)
{
    float theta = deltaTheta * i;
    float phi = deltaPhi * j;
    vec3 w;
    w.y = sin(phi);
    w.x = cos(phi) * cos(theta);
    w.z = cos(phi) * sin(theta);

    // w(sampleDir) is defined by n(normal) as (y axis) in world space which means no rotation/translation.
	// but normal has rotation, therefore it require to rotate sampleDir to proper direction
    w = (rotateMat * vec4(w, 0)).xyz;
    w = normalize(w); // in case of not normalized

    //TODO: the sample raidus should be a random length.
    // wait for implementing the perlin noise at GPU side.(test it like output to screen)
    float randomRatio = 1.0;

    // to determin whether w has occlusion: it has two check
	// first check: coarse check
    float lambda = ssdoSampleRadius * randomRatio;
	vec3 samplePos1 = ePos + w * lambda;  // in view space
	vec3 sampleTexCoord1 = PosToTexCoord(samplePos1);
	return CheckVisibleByDepth(sampleTexCoord1);
}

void main()
{
	fPos = texture(posTex, fUV).rgb; // in world space.
    vec4 temp = texture(normalTex, fUV);
	float flag = temp.w;
	if(flag == 0)
    {
        aoTex = 0;
		discard; // no information in this fragment.
    }
	
	fNormal = temp.xyz; // already be converted to world space normal(check gbuffers.fs)

    // construct frame matrix by using normal as y axis
	vec3 up = vec3(0, 1, 0);
	vec3 y = normalize((viewMat*vec4(fNormal, 0)).xyz);
	vec3 x = normalize(cross(up, y));
	vec3 z = normalize(cross(x, y));
	rotateMat = mat4(vec4(x, 0), vec4(y, 0), vec4(z, 0), vec4(0, 0, 0, 1)); // view space rotateMat

	ePos = (viewMat*vec4(fPos, 1)).xyz; /*vertex position in eye space*/

    /* about "theta" and "phi", check "report_ssdo" page 9. */
    deltaTheta = 2 * PI / 3; // only works for "SSAOScene/scene_ssdo.json"
    deltaPhi = PI * 0.5 / (2 + 1); // only works for "SSAOScene/scene_ssdo.json"

    float totalVisibility = 0.0;
    for(int i=0; i<3; i+=1)
    {
        for(int j=1; j<=2; j+=1)
        {
            totalVisibility += ComputeVisibility(i, j);
        }
    }

    float totalSampleNum = 3 * 2;
    aoTex = (totalSampleNum-totalVisibility) / totalSampleNum;
}
