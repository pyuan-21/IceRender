/* This file is automatically generated by "Resources/Shaders/Filters/Gaussian/Generator/gaussian_filter_generator.py". */
#version 450 core

in vec2 fUV; /*screen quad UV coordinates.*/
uniform sampler2D inputTex; /*- texture needed to be filtered */

layout (location = 0) out #replace:0# result; /* output */

int _GetStartIndex(int row_index)
{
	int startIndex = 0;
	for(int i=0;i<row_index;i++)
			startIndex += (3-i);
	return startIndex;
}

int GetWeightIndex(int x, int y)
{
	/* please check "Resources/Shaders/Filters/Gaussian/Generator/gaussian_filter_generator.py" */
	int absX = abs(x);
	int absY = abs(y);
	if(absY < absX)
	{
		int temp = absX;
		absX = absY;
		absY = temp;
	}
		return _GetStartIndex(2 - absY) + absX;
}

void main()
{
    vec2 texSize = textureSize(inputTex, 0); /*take the size from mipmap at level=0*/
	vec2 texelSize = 1.0/texSize;
    #replace:0# sum = #replace:1#;
	float kernel[6] = { 0.0, 0.0204081632653, 0.0408163265306, 0.0612244897959, 0.0816326530612, 0.102040816327 };
	#iteration:#iterVarInit:-2##iterVarMax:2##iterVarStep:1##iterVarInit:-2##iterVarMax:2##iterVarStep:1##function:    sum += kernel[GetWeightIndex(int(#iterVar:0#), int(#iterVar:1#))] * texture(inputTex, fUV+vec2(#iterVar:0#, #iterVar:1#)*texelSize).#replace:2#;##
	result = sum;
}
	