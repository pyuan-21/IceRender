# (refer)[https://stackoverflow.com/questions/16165666/how-to-determine-the-window-size-of-a-gaussian-filter]
import math
import sys

sigma = None # standard deviation
epsilon = None # value of Gaussian function
sigma_square = None
ratio_1 = None
ratio_2 = None

def Gaussian2D(x, y):
	global ratio_1, ratio_2
	# x,y: random variables
	return ratio_1*math.pow(math.e, ratio_2*( math.pow(x,2) + math.pow(y,2) ))

def InvertGaussian1D():
	# output is upper-bound(x_max) of the random variable x. (x<=x_max)
	# input is value of Gaussian1D().
	global sigma, sigma_square, epsilon
	return math.sqrt( -2*sigma_square* math.log(epsilon*sigma*math.sqrt(2*math.pi) , math.e) )

def _GetStartIndex(row_index, row_len):
	result = 0
	for i in range(row_index):
		result += (row_len - i)
	return result

def GenerateCompressedKernel(kernel_radius):
	# print('kernel_radius: {0}'.format(kernel_radius))
	# [glsl array max size is 12?](https://community.khronos.org/t/array-size-limit/64653),
	# which makes compressed kernel neccessary:
	# since the kernel is x/y symmetric, in order to save the store in glsl shader, 
	# we only generate its half-quarter part.(its quarter part is diagonal-symmetric)
	# an example kernel can be found here: (https://homepages.inf.ed.ac.uk/rbf/HIPR2/gsmooth.htm)
	kernel = list()
	half_quarter_sum = 0
	cnt_test = 0 # TODO: delete it
	for i in range(0, kernel_radius+1):
		for j in range(i, kernel_radius+1):
			v = Gaussian2D(i,j)

			v = cnt_test # TODO: delete it
			cnt_test += 1

			half_quarter_sum += v
			kernel.append(v)

	# print('kernel size: {0}'.format(len(kernel)))
	# print('half_quarter_sum: {0}'.format(half_quarter_sum))

	# An example: 5*5 kernel (radius/kernel_radius=2)
	# [2, 1, 0, 1, 2]
	# [1, 4, 3, 4, 1]
	# [0, 3, 5, 3, 0]
	# [1, 4, 3, 4, 1]
	# [2, 1, 0, 1, 2]
	# total: 5 + 3*4 + 4*4 + 2*4 + 1*8 = 5+12+16+8+8=49

	# for half-quarter kernel with kernel_size=3(kernel_radius) above:
	# i(row) is in range: [0, 2]
	# j(col) is in range: [0, 2]

	# the index computed from i(row) and j(col)
	# [0, 1, 2]
	# [3, 4, _]
	# [5, _, _]

	# Example for deriving the order inside a list of list:
	# test = list()
	# test.append([1,2])
	# test.append([3,4])
	# print(test[0][0]) # print 1
	# print(test[0][1]) # print 2
	# print(test[1][0]) # print 3
	# print(test[1][1]) # print 4
	
	quarter_diagonal = 0
	for i in range(0, kernel_radius+1):
		index = _GetStartIndex(i+1, kernel_radius+1) - 1
		# print('i: {0}, index: {1}'.format(i, index))
		quarter_diagonal += kernel[index]
		# print('kernel[{0}]: {1}'.format(index, kernel[index]))
	# print('quarter_diagonal: {0}'.format(quarter_diagonal))
	quarter_sum = half_quarter_sum * 2 - quarter_diagonal
	# print('quarter_sum: {0}'.format(quarter_sum))
	
	quarter_left = 0
	for i in range(0, kernel_radius+1):
		index = _GetStartIndex(i, kernel_radius+1)
		# print('i: {0}, index: {1}'.format(i, index))
		quarter_left += kernel[index]
	# print('quarter_left: {0}'.format(quarter_left))
	right_half = quarter_sum * 2 - quarter_left
	# print('right_half: {0}'.format(right_half))

	center = _GetStartIndex(kernel_radius, kernel_radius+1)
	# print('center: {0}'.format(center))
	half_center = quarter_left * 2 - center
	# print('half_center: {0}'.format(half_center))

	total = right_half * 2 - half_center
	# print('total: {0}'.format(total))

	# normalize the kernel
	inv_total = 1.0/total
	for i in range(len(kernel)):
		kernel[i] *= inv_total

	return kernel

def TestCorrectness(kernel_radius, kernel):
	sum = 0
	# for testing the correctness of the kernel
	for x in range(-kernel_radius, kernel_radius+1):
		for y in range(-kernel_radius, kernel_radius+1):
			# center is at left-bottom corner.
			# 1) need to convert x/y to row/col(i,j)
			# 2) if y<x then swap it(diagonal symmetry)
			temp_x = x
			temp_y = y

			abs_x = abs(x)
			abs_y = abs(y)
			if abs_y < abs_x:
				abs_x, abs_y = abs_y, abs_x # swap them
			i = kernel_radius - abs_y # row
			j = abs_x # col
			index = _GetStartIndex(i, kernel_radius+1) + j
			print('i:{0}, j:{1}, index:{2}, startIndex:{3}'.format(i, j, index, index-j))
			weight = kernel[index]
			print('x:{0}, y:{1}, weight:{2}'.format(temp_x, temp_y, weight*49))
			sum += weight
	print('sum: {0}'.format(sum))

def GenerateSubShader(kernel_radius, kernel, output_file):
	shader_code = '/* This file is automatically generated by ' + \
		'"Resources/Shaders/Filters/Gaussian/Generator/gaussian_filter_generator.py". */'

	# first part of the code:
	shader_code += \
	"""
#version 450 core

in vec2 fUV; /*screen quad UV coordinates.*/
uniform sampler2D inputTex; /*- texture needed to be filtered */

layout (location = 0) out #replace:0# result; /* output */

int _GetStartIndex(int row_index)
{
	int startIndex = 0;
	for(int i=0;i<row_index;i++)
	"""

	shader_code += '		startIndex += ({0}-i);'.format((kernel_radius+1))

	shader_code += \
	"""
	return startIndex;
}

int GetWeightIndex(int x, int y)
{
	/* please check "Resources/Shaders/Filters/Gaussian/Generator/gaussian_filter_generator.py" */
	int absX = abs(x);
	int absY = abs(y);
	if(absY < absX)
	{
		int temp = absX;
		absX = absY;
		absY = temp;
	}
	"""

	shader_code += '	return _GetStartIndex({0} - absY) + absX;'.format(kernel_radius)

	shader_code += \
	"""
}

void main()
{
    vec2 texSize = textureSize(inputTex, 0); /*take the size from mipmap at level=0*/
	vec2 texelSize = 1.0/texSize;
    #replace:0# sum = #replace:1#;
	"""

	# second part of the code:
	kernel_str = '{ '
	for i, w in enumerate(kernel):
		kernel_str += str(w) + (', ' if i < len(kernel)-1 else '')
	kernel_str += ' }'
	shader_code += 'float kernel[{0}] = {1};\n	'.format(len(kernel), kernel_str)

	shader_code += '#iteration:#iterVarInit:{0}##iterVarMax:{1}##iterVarStep:1#'.format(-kernel_radius, kernel_radius)
	shader_code += '#iterVarInit:{0}##iterVarMax:{1}##iterVarStep:1##function:'.format(-kernel_radius, kernel_radius)
	
	shader_code += '    sum += kernel[GetWeightIndex(int(#iterVar:0#), int(#iterVar:1#))] * texture(inputTex, fUV+vec2(#iterVar:0#, #iterVar:1#)*texelSize).#replace:2#;##'

	shader_code += \
	"""
	result = sum;
}
	"""

	# print('shader_code:\n{0}'.format(shader_code))

	with open(output_file, 'w') as f:
		f.write(shader_code)
	print('{0} has been generated.'.format(output_file))


if __name__ == "__main__":
	sigma = 1
	epsilon = 0.1

	# update sigma, epsilon from inputs if needed
	if(len(sys.argv) >= 3):
		print('using user-input to initialize sigma(standard deviation) and eplison(value of Gaussian function).')
		sigma = float(sys.argv[1])
		epsilon = float(sys.argv[2])
	else:
		print('no user input found, then use default parameters for sigma/epsilon...')
	print('sigma(standard deviation): {0}, eplison(value of Gaussian function): {1}'.format(sigma, epsilon))

	sigma_square = math.pow(sigma, 2)
	ratio_1 = 1.0/(2*math.pi*sigma_square)
	ratio_2 = -1.0/(2*sigma_square)

	# this is for computing the radius which can cover the area where all values of Gaussian can be greater than epsilon
	value = InvertGaussian1D()
	kernel_radius = int(math.ceil(value))
	print('1D Gaussian, random variable x <= {0}, then kernel radius: {1}'.format(value, kernel_radius))

	kernel = GenerateCompressedKernel(kernel_radius)

	# TestCorrectness(kernel_radius, kernel) # for testing purpose

	# generate ".iter_fs" file
	# need to use '#replace:index' tag to convert it to correct one
	# e.g. 'gaussianFilter_Float.iter_fs' or 'gaussianFilter_Vec3.iter_fs'
	output_file = 'gaussianFilter_Template.iter_fs' 
	GenerateSubShader(kernel_radius, kernel, output_file)