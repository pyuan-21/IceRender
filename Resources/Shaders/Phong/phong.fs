/* This file is automatically generated by "Resources/Shaders/Phong/phong_vsm.main_fs". */
#version 450 core
#pragma optionNV (unroll all)

in vec3 fPos;
in vec3 fNormal;
in vec2 fUV;

/*matrix*/
uniform mat4 modelMat;
uniform mat4 viewMat;

/*ambient*/
uniform vec3 ambientLight;

/*lights*/
uniform int activeLightNum;
const int maxLightNum = 5; /*TODO:don't forget to modify its corresponding variable in SceneManager*/
struct Light
{
	int type;
	vec3 color, pos, dir; /*color, position, direction*/
	float intensity;
	vec2 attenuation;

	/*shadow relevant*/
	int renderShadow;
};
uniform Light lights[maxLightNum];

uniform int useAlbedoTex;

/*material*/ 
struct Material
{
	vec3 ka, kd, ks, color; /*coefficient for ambient, diffuse, specular and color*/
	float shiness;
	sampler2D albedoTex;
};
uniform Material material; 

// import sub shader from other file
/*light info*/
struct LightCamInfo
{
	mat4 lightMat;
	float near;
	float far;
	vec3 lightCamPos;
	vec3 lightViewDir;
};
uniform LightCamInfo lightCamInfos[maxLightNum]; // "maxLightNum" is defined in "phong_vsm.main_fs"

/*shadow map*/
uniform sampler2D shadowMaps[maxLightNum]; // "maxLightNum" is defined in "phong_vsm.main_fs"

/*SAT-VSM related, refer GPUGems3: SummedArea Variance ShadowMaps*/
uniform int halfKernelSize; /*half kernel size: e.g. 2 is 5X5 kernel*/
uniform float varMin; /*minimum variance to reduce numeric inaccuracy(also biasing)*/
uniform float pMin; /*remove range[0, pMin], then rescale pMax from range[pMin, 1] to [0,1]*/
uniform int useSAT; /*indicate whether use SAT to do filtering*/
uniform sampler2D SATMaps[maxLightNum]; // "maxLightNum" is defined in "phong_vsm.main_fs"


/*Given a center, half kernel size and its SAT map, return the mean of this kernel area*/
vec2 GetMean(ivec2 texSize, ivec2 center, sampler2D SATMap)
{
	// [Note] texel space coordinate is inside [0, resolution-1]. 
	ivec2 minCorner = center - ivec2(halfKernelSize+1);
	ivec2 maxCorner = center + ivec2(halfKernelSize);
	// don't clamp corner first, because we do need some values which are out of range to compute true sum.
	// those elements out of range will return border value, here it is zero.
	vec4 result4 = texelFetch(SATMap, maxCorner, 0) - texelFetch(SATMap, ivec2(minCorner.x, maxCorner.y), 0) - texelFetch(SATMap, ivec2(maxCorner.x, minCorner.y), 0) + texelFetch(SATMap, minCorner, 0);

	// compute the real number over kernel area, must clamp corner.
	minCorner = clamp(minCorner, ivec2(0), texSize-ivec2(1));
	maxCorner = clamp(maxCorner, ivec2(0), texSize-ivec2(1));
	int totalNum = max(maxCorner.x-minCorner.x, 1) * max(maxCorner.y-minCorner.y, 1);
	vec2 loss = vec2(0.5); // don't forget compensate this loss
	vec2 menOutput = result4.xy/totalNum + loss; //totalLoss = loss * totalNum-> its mean loss is loss
	return menOutput;
}

struct TexelInfo
{
	ivec2 lb, lt, rb, rt; /*four texel coordinates at four corners over a rectangle area*/
	vec2 weight;
};

/*return four texels which are surrounding the uvCoord. We can use these four texels to do bilinear interpolation*/
TexelInfo GetFourTexels(ivec2 texSize, vec2 texelSize, vec2 uvCoord)
{
	float weightX, weightY;
	int minX, maxX, minY, maxY; // in texel space [0, resolution-1]
	ivec2 texelNum = ivec2(uvCoord/texelSize); // check how many completed texels it has already contained.
	vec2 offset = uvCoord - texelNum*texelSize;
	vec2 halfTexelSize = 0.5 * texelSize;
	
	// X direction
	if(offset.x < halfTexelSize.x)
	{
		minX = texelNum.x - 1;
		weightX = (halfTexelSize.x+offset.x)/(texelSize.x);
	}
	else
	{
		minX = texelNum.x;
		weightX = (offset.x-halfTexelSize.x)/(texelSize.x);
	}
	maxX = minX + 1;

	// clamp the range, must execute after computation. Don't do it above
	minX = clamp(minX, 0, texSize.x-1);
	maxX = clamp(maxX, 0, texSize.x-1);

	// Y direction
	if(offset.y < halfTexelSize.y)
	{
		minY = texelNum.y - 1;
		weightY = (halfTexelSize.y+offset.y)/(texelSize.y);
	}
	else
	{
		minY = texelNum.y;
		weightY = (offset.y-halfTexelSize.y)/(texelSize.y);
	}
	maxY = minY + 1;

	minY = clamp(minY, 0, texSize.y-1);
	maxY = clamp(maxY, 0, texSize.y-1);

	TexelInfo texelInfo;
	texelInfo.lb = ivec2(minX, minY);
	texelInfo.lt = ivec2(minX, maxY);
	texelInfo.rb = ivec2(maxX, minY);
	texelInfo.rt = ivec2(maxX, maxY);
	texelInfo.weight = vec2(weightX, weightY);

	return texelInfo;
}

/*return bilinear interpolation*/
vec2 GetBilinearValue(vec2 lb, vec2 lt, vec2 rb, vec2 rt, vec2 weight)
{
	vec2 res1 = mix(lb, rb, weight[0]); // bottom horizontal interpolation
	vec2 res2 = mix(lt, rt, weight[0]); // top horizontal interpolation
	return mix(res1, res2, weight[1]); // from bottom to top, vertical interpolation
}

/*average the depth/depth_square over kernel*/
vec2 GetMoment(vec2 uvCoord, sampler2D shadowMap, sampler2D SATMap)
{
	float M1 = 0.0, M2 = 0.0;
	
	/*moment is vec2(E(x), E(x^2)), that's why we need a kernel to filter an area to get mean*/
	/*filtering*/
	if(useSAT == 1)
	{
		// [Note] texel space coordinate is inside [0, resolution-1]. 
		ivec2 texSize = textureSize(SATMap, 0);
		vec2 texelSize = 1.0/texSize;

		/*nearest mean*/ 
		{
			//ivec2 center = ivec2(uvCoord/texelSize);
			//center = clamp(center, ivec2(0), texSize-ivec2(1));
			//vec2 nearestMean = GetMean(texSize, center, SATMap);
			//M1 = nearestMean.x;
			//M2 = nearestMean.y;
		}

		/*Bilinear interpolation is better*/
		TexelInfo texelInfo = GetFourTexels(texSize, texelSize, uvCoord);
		vec2 lbMean = GetMean(texSize, texelInfo.lb, SATMap);
		vec2 ltMean = GetMean(texSize, texelInfo.lt, SATMap);
		vec2 rbMean = GetMean(texSize, texelInfo.rb, SATMap);
		vec2 rtMean = GetMean(texSize, texelInfo.rt, SATMap);

		/*We need to do linear interpolation by ourselves. SAT can not use texture() to get value.*/
		/*SAT is texel based, can not be used to interpolation.*/
		vec2 biliRes = GetBilinearValue(lbMean, ltMean, rbMean, rtMean, texelInfo.weight);
		M1 = biliRes.x;
		M2 = biliRes.y;
	}
	else
	{
		vec2 texelSize = 1.0/textureSize(shadowMap, 0);
		int totalNum = 0;
		for(int i = -halfKernelSize; i <= halfKernelSize; i++)
		{
			for(int j = -halfKernelSize; j <= halfKernelSize; j++)
			{
				vec2 value = texture(shadowMap, uvCoord+vec2(i,j)*texelSize).rg;
				M1 += value.r;
				M2 += value.g;
				totalNum += 1;
			}
		}
		float invSize = 1.0 / totalNum;
		M1 *= invSize;
		M2 *= invSize;
	}

	return vec2(M1, M2);
}

float ComputeChebychevUpperBound(float t, vec2 moment)
{
	if(t<=moment.x)
		return 1.0;

	/*moment is vec2(E(x), E(x^2))*/
	float differ = t - moment.x; /*depth minus mean*/
	/*using this math formula will get some variance less than zero because of float-precision or other reason*/
	float variance = max(moment.y - moment.x*moment.x, 0); /*variance square*/
	variance = max(variance, varMin);
	return variance / (variance + differ*differ);
}

float ComputeLightRatio(LightCamInfo lightCamInfo, sampler2D shadowMap, sampler2D SATMap)
{
	/*ComputeLightRatio: lightRatio is inside [0, 1]*/
	vec4 clipCoord = lightCamInfo.lightMat*modelMat*vec4(fPos,1.0); /*clip space*/
	vec3 ndcCoord = clipCoord.xyz / clipCoord.w; /*ndc space: [-1,1]^3*/ 
	vec3 shadowCoord = (ndcCoord+1)/2.0; /*map [-1,1]^3 to [0,1]^3*/
	/*note this frageDepth is not clipped. We need to check it by ourselves if neccessary.*/  
	/*we can just set no-shadow for those vertices which are outside of the light view frustum*/
	//float fragDepth = shadowCoord.z; // this is projected depth, don't use it

	/*[Important] for avoid projected z-depth precision issue, using linear depth not projected depth*/
	/*we know z values near to far plane will be hard to compare*/
	vec3 worldPos = (modelMat*vec4(fPos,1.0)).xyz;
	vec3 v = worldPos - lightCamInfo.lightCamPos;
	vec3 proAxis = normalize(lightCamInfo.lightViewDir);
	float linearDepth = dot(v, proAxis);
	linearDepth = (linearDepth - lightCamInfo.near) / (lightCamInfo.far - lightCamInfo.near);
	float fragDepth = linearDepth;

	vec2 moment = GetMoment(shadowCoord.xy, shadowMap, SATMap);
	float pMax = ComputeChebychevUpperBound(fragDepth, moment);
	pMax = (pMax-pMin)/(1.0-pMin); /*linear interpolation-map the [pMin, 1] to [0, 1]*/
	pMax = clamp(pMax, 0, 1);

	return pMax;
}


out vec4 colorResponse;

void main()
{
	vec3 albedo;
	if(useAlbedoTex==1)
		albedo = texture(material.albedoTex, fUV).rgb;
	else
		albedo = material.color;

	vec3 ePos = (viewMat*modelMat*vec4(fPos, 1)).xyz; /*vertex position in eye space*/

	vec3 lRes = vec3(0); /*lighting response*/

	vec3 ambient = ambientLight*material.ka;

	for(int i=0;i<activeLightNum;i++)
	{
		/*lighting computation is in "eye space"*/
		Light light = lights[i];
		float lI = light.intensity;
		vec3 lPos = (viewMat*vec4(light.pos, 1)).xyz;
		vec3 lDir;
		if(light.type == 0)
		{
			/*point light*/ 
			lDir = lPos - ePos;
			float d = length(lDir);
			lI *= 1.0 / (1 + d*light.attenuation.x + pow(d,2)*light.attenuation.y);
		}
		else if(light.type == 1)
		{
			lDir = (viewMat*vec4(light.dir, 0)).xyz;
		}
		lDir = normalize(lDir);
		vec3 lC = light.color*lI; /*light color(or color intensity) at this vertex.*/
		
		/*refer: https://en.wikipedia.org/wiki/Phong_reflection_model, but I have my own modification*/

		vec3 eN = normalize((transpose(inverse(viewMat*modelMat))*vec4(fNormal, 0)).xyz);

		/*diffuse*/ 
		/*use 0 for normal's forth component in homogenous coordinate, cause translation should not be applied to normal vector*/
		vec3 diffuse = vec3(0);		
		float lDirDotN = dot(lDir,eN);
		if(lDirDotN > 0)
			/*albedo and incoming light control the color response at this vertex point*/
			diffuse = material.kd*lDirDotN*lC;

		/*specular*/
		vec3 specular = vec3(0);
		vec3 lRef = normalize(2*lDirDotN*eN-lDir); /*light reflection direction*/
		vec3 eV = normalize(-ePos); /*eye view direction at this vertex. In eye space, camera is at origin*/
		float lRefDotN = dot(lRef, eV);
		if(lRefDotN > 0)
			specular = material.ks*pow(lRefDotN, material.shiness)*lC;

		/*shadow is the result of light source(direct light), not ambient(indirect light)*/
		vec3 sum = diffuse + specular;
		float lightRatio = 1.0;
		if(light.renderShadow == 1)
		{
			// below code line("ComputeLightRatio") is defined in sub shader "VarianceShadowMap/lightRatio.sub_fs"
			lightRatio = ComputeLightRatio(lightCamInfos[i], shadowMaps[i], SATMaps[i]);
		}

		lRes += (sum*lightRatio);
	}

	lRes += ambient;
	lRes *= albedo; /*albedo determines how much lighting reflect from the surface*/

	colorResponse = vec4(lRes, 1);
}
